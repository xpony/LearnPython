#递归函数   在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。
#我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：
#fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n
#所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理
#于是，fact(n)用递归的方式写出来就是：
def fact(n):
	if n==1:
		return 1
	return n * fact(n - 1)  #直到调用完所有fact(),最后返回值
print(fact(10))
#尾递归优化
#使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，
#每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，
#所以，递归调用的次数过多，会导致栈溢出。
#比如print(fact(1000))就会出错

#解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，
#所以，把循环看成是一种特殊的尾递归函数也是可以的。

#尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，
#编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。


#上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：
def fact(n, sum=1):
	if n==1:
		return sum
	sum = sum * n
	return fact(n - 1,  sum)  
print(fact(10))   # return中不在含有表达式了， sum在函数调用前就会被计算出来
#尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

#遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，
#所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。
####服了，这……

# 利用递归函数移动汉诺塔:
def move(n, a, b, c):
    if n == 1:
        print('move', a, '-->', c)
    else:
        move(n-1, a, c, b)   # 把a上的n-1个盘子借助c移动到b
        move(1, a, b, c)     # 把a上1个盘子移动到c
        move(n-1, b, a, c)   # 把b上的n-1个盘子借助a移动到c

move(4, 'A', 'B', 'C')







